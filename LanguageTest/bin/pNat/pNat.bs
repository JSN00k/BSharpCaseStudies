package pNat

From Relations Import Relations.*

Datatype pNat
| zero
| suc(prev : pNat) {
	add(x, y : pNat) : pNat INFIX 100
		match x {
			| zero : y
			| suc(xs) : suc(xs add y)
		} 
	
	add2(x : pNat) : pNat suc(suc(x)) 
	
	Instance Setoid<pNat>([=])
	
	Theorems {
		suc out of addition:
		  ∀ x, y : pNat · x add suc(y) = suc(x add y);
		add zero:
		  ∀ x : pNat · x add zero = x;
	}
} 

From Monoids Import Monoid.* 
CommMonoid.*

Extend pNat (mon_Add) {
	Instance CommMonoid<pNat>(add, zero) addMon (times = raiseToL) 
	
	Instance CommMonoid<pNat>(times, suc(zero)) timesMon (power = raiseToL) 
}

Extend pNat (minus) {
		decr(x : pNat) : pNat
		match x {
			| zero : zero
			| suc(xs) : xs 
		}
	
	minus(x, y : pNat) : pNat INFIX 99 
		match y {
			| zero : x
			| suc(ys) : decr(x minus ys)
		}
}

Extend pNat (divide) {
	divMod(n, d, count : pNat) : pNat × pNat 
	  match n {
	  	| zero : (zero, zero)
	  	| suc(ns) : 
	  		if suc(ns) = d {
	  			(suc(count), zero)
	  		} else {
	  			if suc(ns) minus d = zero {
	  				(count, suc(ns))
	  			} else {
	  				divMod(suc(ns) minus d, d, suc(count))
	  			}
	  		}
	  	}
}

